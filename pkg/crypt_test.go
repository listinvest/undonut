package undonut

import "testing"

func TestChaskey(t *testing.T) {
	key := [16]byte{0x56, 0x09, 0xe9, 0x68, 0x5f, 0x58, 0xe3, 0x29, 0x40, 0xec, 0xec, 0x98, 0xc5, 0x22, 0x98, 0x2f}
	plainText := [16]byte{0xb8, 0x23, 0x28, 0x26, 0xfd, 0x5e, 0x40, 0x5e, 0x69, 0xa3, 0x01, 0xa9, 0x78, 0xea, 0x7a, 0xd8}
	cipherText := [16]byte{0xd5, 0x60, 0x8d, 0x4d, 0xa2, 0xbf, 0x34, 0x7b, 0xab, 0xf8, 0x77, 0x2f, 0xdf, 0xed, 0xde, 0x07}
	result, err := Chaskey(key, plainText)
	if err != nil {
		t.Errorf("unexpected error: %s", err.Error())
	}

	if result != cipherText {
		t.Errorf("ciphertext mismatch, expected: %v, got: %v", cipherText, result)
	}
}

func TestEncryptDonut(t *testing.T) {
	key := [16]byte{0x56, 0x09, 0xe9, 0x68, 0x5f, 0x58, 0xe3, 0x29, 0x40, 0xec, 0xec, 0x98, 0xc5, 0x22, 0x98, 0x2f}
	ctr := [16]byte{0xd0, 0x01, 0x36, 0x9b, 0xef, 0x6a, 0xa1, 0x05, 0x1d, 0x2d, 0x21, 0x98, 0x19, 0x8d, 0x88, 0x93}
	finalCtr := [16]byte{0xd0, 0x01, 0x36, 0x9b, 0xef, 0x6a, 0xa1, 0x05, 0x1d, 0x2d, 0x21, 0x98, 0x19, 0x8d, 0x8b, 0x13}

	data := make([]byte, 77)

	for i := 0; i < 128; i++ {
		var err error
		// encrypt data
		data, ctr, err = DonutEncrypt(key, ctr, data)
		if err != nil {
			t.Errorf("unexpected error: %s", err.Error())
		}
		// update key with first 16 bytes of ciphertext
		for j := 0; j < 16; j++ {
			key[j] ^= data[j]
		}
	}

	if ctr != finalCtr {
		t.Errorf("ciphertext mismatch, expected: %v, got: %v", ctr, finalCtr)
	}
}
